/**
 * color_wheels.comp -- Lift / Gamma / Gain Color Correction (Vulkan Compute)
 *
 * Vulkan compute shader equivalent of the CUDA color_wheels kernel.
 * Applies a three-way color correction using the standard Lift / Gamma / Gain
 * model used in professional color grading. Alpha is preserved.
 *
 * Formula (per channel c in {r, g, b}):
 *   out.c = gain.c * pow(in.c + lift.c * (1 - in.c), 1.0 / (1.0 + gamma.c))
 *
 * Lift  : adjusts shadows (dark regions)
 * Gamma : adjusts midtones
 * Gain  : adjusts highlights (bright regions)
 *
 * Binding layout:
 *   set 0, binding 0: Input  RGBA (readonly storage buffer, uint-packed)
 *   set 0, binding 1: Output RGBA (writeonly storage buffer, uint-packed)
 *
 * Push constants:
 *   width   : Image width in pixels (uint)
 *   height  : Image height in pixels (uint)
 *   lift_r  : Red lift [-1, 1]. 0 = no change.
 *   lift_g  : Green lift [-1, 1]. 0 = no change.
 *   lift_b  : Blue lift [-1, 1]. 0 = no change.
 *   gamma_r : Red gamma [-1, 1]. 0 = no change.
 *   gamma_g : Green gamma [-1, 1]. 0 = no change.
 *   gamma_b : Blue gamma [-1, 1]. 0 = no change.
 *   gain_r  : Red gain [0, 3]. 1 = no change.
 *   gain_g  : Green gain [0, 3]. 1 = no change.
 *   gain_b  : Blue gain [0, 3]. 1 = no change.
 */

#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ---------------------------------------------------------------------------
// Storage buffers
// ---------------------------------------------------------------------------
layout(set = 0, binding = 0) readonly buffer InputBuf {
    uint data[];
} input_buf;

layout(set = 0, binding = 1) writeonly buffer OutputBuf {
    uint data[];
} output_buf;

// ---------------------------------------------------------------------------
// Push constants
// ---------------------------------------------------------------------------
layout(push_constant) uniform Params {
    uint  width;
    uint  height;
    float lift_r;
    float lift_g;
    float lift_b;
    float gamma_r;
    float gamma_g;
    float gamma_b;
    float gain_r;
    float gain_g;
    float gain_b;
} params;

// ---------------------------------------------------------------------------
// Helpers: pixel I/O
// ---------------------------------------------------------------------------
vec4 readPixel(uint x, uint y)
{
    uint idx = y * params.width + x;
    uint packed = input_buf.data[idx];
    return vec4(
        float((packed >>  0) & 0xFFu) / 255.0,
        float((packed >>  8) & 0xFFu) / 255.0,
        float((packed >> 16) & 0xFFu) / 255.0,
        float((packed >> 24) & 0xFFu) / 255.0
    );
}

void writePixel(uint x, uint y, vec4 color)
{
    uint idx = y * params.width + x;
    color = clamp(color, 0.0, 1.0);
    uint packed = (uint(color.r * 255.0) <<  0) |
                  (uint(color.g * 255.0) <<  8) |
                  (uint(color.b * 255.0) << 16) |
                  (uint(color.a * 255.0) << 24);
    output_buf.data[idx] = packed;
}

// ---------------------------------------------------------------------------
// Helper: apply lift-gamma-gain to a single channel
// ---------------------------------------------------------------------------
float lift_gamma_gain(float val, float lift, float gamma, float gain)
{
    // Lift: add to shadows (weighted by 1-val so it affects darks more)
    float lifted = val + lift * (1.0 - val);
    lifted = max(lifted, 0.0);

    // Gamma: power curve for midtones
    float gamma_exp = 1.0 / max(1.0 + gamma, 0.001);
    float graded = pow(lifted, gamma_exp);

    // Gain: multiply the result
    return graded * gain;
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------
void main()
{
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;

    if (x >= params.width || y >= params.height)
        return;

    // -------------------------------------------------------------------
    // 1. Read RGBA pixel (normalized to [0, 1])
    // -------------------------------------------------------------------
    vec4 pixel = readPixel(x, y);

    // -------------------------------------------------------------------
    // 2. Apply lift / gamma / gain per channel
    // -------------------------------------------------------------------
    pixel.r = lift_gamma_gain(pixel.r, params.lift_r, params.gamma_r, params.gain_r);
    pixel.g = lift_gamma_gain(pixel.g, params.lift_g, params.gamma_g, params.gain_g);
    pixel.b = lift_gamma_gain(pixel.b, params.lift_b, params.gamma_b, params.gain_b);

    // -------------------------------------------------------------------
    // 3. Write output (alpha preserved, writePixel clamps)
    // -------------------------------------------------------------------
    writePixel(x, y, pixel);
}
